# 任务的概念
以一个例子引入多任务，请看图：
![妈妈喂小孩&工作示意图](https://note-pic.zhang33.net:8443/嵌入式知识库/FreeRTOS及其项目合集/模块2-FreeRTOS快速入门/妈妈喂小孩&工作示意图.png#pic_center)
这个例子中，妈妈有两件事情可以做：
1. 给小孩喂饭；
2. 工作。

引申开来，妈妈就是嵌入式系统中的处理器，而那两件事情就是两个任务。那么在程序里面，任务是怎么表现的？在回答这个问题之前，我们首先需要了解一个概念，就是：什么事任务？
## 1_1-什么是任务？
反例：任务是函数？
解释：这肯定是不对的，或者说不是完全准确的。如果任务是函数，那么下面这段代码：
```C
void Task1Function(void *param)
{
    while(1)
    {
	    printf("1");
    }
}
```
这是一个任务吗？其实不能这么说，它是任务的一个函数，是任务的一部分，DNA不是任务。对任务而言，我们是可以对它进行创建、删除、切换等操作的。如果一个函数就等于任务的话，这个函数，保存在 flash 中，在我们切换任务的时候并不需要保存它；换句话说，既然它已经被保存在 flash 中了，也就不存在什么创建、删除这些概念了。

**所以函数是任务的一部分，不是任务的全部。** 

那么任务到底是什么？我们可以这样认为：任务就是一个运行着的函数。看如下代码辅助理解：
```C
void add_val(int *pa, int *pb)
{
    volatile int tmp;
    tmp = *pa;
    *pa = tmp + *pb;
}

void TaskFunction(void *param)
{
	int a = 1;
	int b = 2;
	add_val(&a, &b);
}
```
我们看下它怎么运行。理解这段代码的运行机制之前，首先需要简单了解一下 ARM 架构，所以需要先说明一下 ARM 架构。
## 1_2-简单认识 ARM 架构
一块单片机里边大概有如下 3 样东西：  
![最简易的ARM架构示意图](https://note-pic.zhang33.net:8443/嵌入式知识库/FreeRTOS及其项目合集/模块2-FreeRTOS快速入门/最简易的ARM架构示意图.png#pic_center)  
简单任务，一个芯片内部至少有上面 3 个部件。之前 C 语言中说过一个原则：**变量变量，能变，能读能写，他必定是在内存里**。
```C
int a = 1;
int b = 2;
```
这两个变量必定是在内存里。那么对于语句：
```C
a = a + b;
```
怎么执行？对于内存而言，说破天他只能是读写数据，那谁来计算？是由 CPU 来完成计算的。  
![ARM架构如何执行a+b示意图](https://note-pic.zhang33.net:8443/嵌入式知识库/FreeRTOS及其项目合集/模块2-FreeRTOS快速入门/ARM架构如何执行a+b示意图.png#pic_center)  
CPU 把变量 a、b 从内存中读出来，完成 a+b 然后再将结果写入内存中，这个过程中又有几个问题需要我们去思考：
1. CPU 从内存中把变量的值读取出来保存到 CPU 的哪里？
2. 运算完成之后的结果有保存的 CPU 的哪里？

上述 4 步运算过程细化一下：  
![ARM架构计算a+b详细流程示意图](https://note-pic.zhang33.net:8443/嵌入式知识库/FreeRTOS及其项目合集/模块2-FreeRTOS快速入门/ARM架构计算a+b详细流程示意图.png#pic_center)  
来分析下这个过程：
1. CPU 从内存中把变量 a 的值读入 CPU 的 R0 寄存器；
2. CPU 从内存中把变量 b 的值读入 CPU 的 R1 寄存器；
3. CPU 计算 a 和 b 这两个变量值的和，然后放入 CPU 的 R0 寄存器；
4. CPU 将 R0 寄存器的值写到内存变量 a 的位置。

在这个过程中，CPU 是如何知道要依次做上面 4 件事情的？那肯定是程序员打了招呼。程序员将编写好的程序保存到 Flash 中，CPU 从 Flash 中取出指令，根据指令忠诚的执行它。这些指令又是怎么样的？继续往下看。
## 1_3-简单汇编指令
TODO
## 1_4-保存现场和恢复现场
- 保存地址  
当程序运行到某个地方或者说某个地址突然被打断，我们是需要将这个地址保存下来的，比如前面那张图中的 0x08001108，我们是需要将这个地址保存下来以便打断的任务完成后回到这里来继续运行后面未完成的动作的。
- 保存寄存器  
我们需要将打断前的寄存器的值保存下来，同理也是为了让 CPU 完成打断的任务之后回到保存下来的那个地址继续执行未完成动作时知道被打断前的寄存器的值，只有这样才能在执行之后的动作得到正确的结果。
- 现场保存的位置  
CPU 将打断前的程序运行到的地址、寄存器的值保存到栈中，当执行完打断后又从栈中读取出来恢复现场继续执行。
## 1_5-栈的作用
前面的汇编代码中，我们只分析了 add_val 函数中的 LDR、ADD 和 STR 指令，但是一开始的
```S
PUSH [r2,lr]
```
是在做什么？它有这 3 个过程：  
![压栈三部曲示意图（简易版）](https://note-pic.zhang33.net:8443/嵌入式知识库/FreeRTOS及其项目合集/模块2-FreeRTOS快速入门/压栈三部曲示意图（简易版）.png#pic_center)

PUSH，压栈，其实本质上也是 STR 写内存指令，做了 3 件事情：
1. 把返回地址 LR 放入栈里（LR 中保存的就是返回地址）；
2. 把 R3 寄存器中的值放入栈里；
3. SP = SP -8  

问：为什么是 sp 是减 8？  
答：因为往栈中写入了两个寄存器的值，在 32bits 中一个寄存器占 32 bits，也就是 4 个字节，这里是两个寄存器，也就是用了 8 个字节，因而是 SP-8。  
问：返回地址是多少？R3 是干什么用的？  
答：  
![程序执行过程中压栈返回地址说明](https://note-pic.zhang33.net:8443/嵌入式知识库/FreeRTOS及其项目合集/模块2-FreeRTOS快速入门/程序执行过程中压栈返回地址说明.png#pic_center)
BL.W 是一条汇编指令：branch and link，译为跳转、保存返回地址。它保存的是下一条汇编指令的地址：
![BLW指令运行示意图](https://note-pic.zhang33.net:8443/嵌入式知识库/FreeRTOS及其项目合集/模块2-FreeRTOS快速入门/BLW指令运行示意图.png#pic_center)

它要保存的就是`preSetupHardware`这条汇编指令的地址：0x080011B6。  
再来看看局部变量在栈中如何体现：  
TODO
# 02-任务的表示
一个任务由以下几个点组成：
- 函数；
- 地址：运行到何处；
- 栈；
- 寄存器的值。  

其中地址和寄存器的值都可以保存到栈中，因此可以用以下这个结构体来表示一个任务：
```C
struct Task{
	// 函数运行到何处，即函数的位置;
	// 栈的位置，即 SP;
}
```
FreeRTOS 中，表示一个任务最核心的结构体如下：  
![FreeRTOS中描述任务的核心结构体tsTaskControlBlock定义](https://note-pic.zhang33.net:8443/嵌入式知识库/FreeRTOS及其项目合集/模块2-FreeRTOS快速入门/FreeRTOS中描述任务的核心结构体定义.png#pic_center)  
结构体内容：  
![FreeRTOS中描述任务的核心结构体tsTaskControlBlock内容](https://note-pic.zhang33.net:8443/嵌入式知识库/FreeRTOS及其项目合集/模块2-FreeRTOS快速入门/FreeRTOS中描述任务的核心结构体内容.png#pic_center)  
打叉的地方并不是必须的，因为他们都在各种宏开关里。在上图中，着重画出了表示栈的变量：栈头、栈尾；但是没有看到函数指针！在创建任务结构体的时候，把函数的位置保存到了栈里，所以这个结构体最核心的内容就是栈，**但是我们不能够认为：任务就是栈**。因为：
- 栈里保存有：函数的地址、寄存器的值等；
- 每个任务都有自己的栈，如果任务 1、任务 2 使用相同的栈，任务 1 的局部变量就会被任务 2 给破坏掉。